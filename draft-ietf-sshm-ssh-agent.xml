<?xml version="1.0" encoding="utf-8"?>
<?xml-model href="rfc7991bis.rnc"?>
<!-- <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> --> 
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-ietf-sshm-ssh-agent-14"
  ipr="trust200902"
  obsoletes=""
  updates=""
  consensus="true"
  submissionType="IETF"
  xml:lang="en"
  version="3">
<!-- 
    * docName should be the name of your draft
    * category should be one of std, bcp, info, exp, historic
    * ipr should be one of trust200902, noModificationTrust200902, noDerivativesTrust200902, pre5378Trust200902
    * updates can be an RFC number as NNNN.
    * obsoletes can be an RFC number as NNNN 
-->

<front>
	<title>SSH Agent Protocol</title>
	<seriesInfo name="Internet-Draft" value="draft-ietf-sshm-ssh-agent-14"/>
	<author fullname="Damien Miller" initials="D." surname="Miller">
		<organization>OpenSSH</organization>
		<address>
			<email>djm@openssh.com</email>  
			<uri>https://www.openssh.com/</uri>
		</address>
	</author>
	<date />
	<area>General</area>
	<workgroup>Internet Engineering Task Force</workgroup>
	<keyword>ssh</keyword>
	<keyword>agent</keyword>
	<keyword>ssh-agent</keyword>
	<abstract>
		<t>
		This document specifies a key agent protocol for use in
		the Secure Shell (SSH) protocol.
		</t>
	</abstract>
	<note removeInRFC="true">
		<t>
		In the IANA considerations section, please replace
		"thisRFC" with "RFC" and the assigned number, when known.
		</t>
	</note>
</front>

<middle>
<section><name>Introduction</name>
	<t>
	Secure Shell (SSH)
	<xref target="RFC4251" />
	is a protocol for secure remote connections
	<xref target="RFC4253" />
	and login
	<xref target="RFC4254" />
	over untrusted networks.
	It supports multiple authentication mechanisms
	<xref target="RFC4252" />,
	including public key authentication. This document
	specifies the protocol for interacting with a key
	management component, usually referred to as "an agent",
	that holds private keys. SSH clients (and possibly
	SSH servers) can invoke the agent via this protocol
	to perform operations using public and private keys
	held in the agent.
	</t>
	<t>
	Holding keys in an agent offers usability and security
	advantages to loading and unwrapping them at each use, as
	each key unwrapping may require entry of a pass-phrase.
	Access to an agent may optionally be forwarded across an SSH connection,
	thereby allowing remote systems to use stored keys without directly
	exposing the key material to the remote system.
	Finally, the agent may be implemented as a dedicated component that
	presents a smaller attack surface than a key loaded into
	a full SSH server or client, and which may be subject to special
	protection from the wider system.
	</t>
	<section removeInRFC="true"><name>Background</name>
		<t>
		This agent protocol is already widely used and a de-facto
		standard, having been implemented by a number of popular
		SSH clients and servers for many years. The purpose of
		this document is to describe the protocol as it has been
		implemented.
		</t>
	</section>      
	<section anchor="requirements"><name>Requirements Language</name>
		<t>
		The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
	        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
	        RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
	        interpreted as described in BCP 14 <xref target="RFC2119"/>
	        <xref target="RFC8174"/> when, and only when, they appear in
	        all capitals, as shown here.
		</t>
	</section>
</section>
    
<section><name>Protocol Overview</name>
	<t>
	The agent protocol is a packetised request-response protocol,
	solely driven by the client. It consists of a number of
	requests sent from a client to an agent and a set of reply
	messages that are sent in response. At no time does the agent
	send messages except in response to a client request. Replies
	are sent in order.
	</t>
	<t>
	These requests include the ability to load keys into an agent,
	remove some or all keys from an agent and to perform signature
	operations using previously-loaded keys.
	</t>
	<t>
	Agents MAY implement support for only a subset of operations
	or available key types, and MAY additionally refuse arbitrary
	operations in particular contexts. For example, an agent may
	allow only clients local to itself to add or remove keys, or
	make particular subsets of keys available to a given client.
	For this reason, clients of the agent SHOULD be prepared to
	fail gracefully if any operation is refused.
	</t>
	<section removeInRFC="true"><name>Background</name>
		<t>
		Note that this protocol is separate to and incompatible with
		the one described in the similarly-named
		<xref target="draft-ietf-secsh-agent-02" /> which expired
		in 2004.
		</t>
	</section>
	<section><name>Terminology and units</name>
		<t>
		Henceforth in this document, "agent" will be used to refer to a
		key management component that implements the responder side of
		this protocol. "Client" will refer to a tool that implements
		the requester side of the protocol to communicate with an agent.
		If it is pertinent that the client in question is a
		<xref target="RFC4251" /> Secure Shell client, then it will be
		explicitly referred to as an "SSH client".
		Similarly "SSH server" will be used to refer to Secure Shell
		servers.
		</t>
		<t>
		All encoding data types ("byte", "uint32", "string", etc.) are
		as specified in <xref target="RFC4251" section="5" />.
		Additionally, the type "byte[]" without a specified length
		within the square brackets indicates an unadorned sequence of
		zero or more bytes where the length is determined by context.
		</t>
		<t>
		All length units are given in bytes unless otherwise specified.
		</t>
	</section>
</section>
    
<section><name>Protocol Messages</name>
	<t>
	Messages consist of a length, type and contents.
	</t>
	<sourcecode>
    uint32            length
    byte              type
    byte[length - 1]  contents
	</sourcecode>
	<t>
	In the sections below, the "length" field is omitted. For
	clarity, the symbolic names of the message types are shown;
	their numeric values are listed in <xref target="messagenum"/>
	below.
	</t>

	<section><name>Generic agent responses</name>
		<t>
		The following generic messages may be sent by the agent
		in response to requests from the client. On success the
		agent MUST reply either with the single-byte response:
		</t>
		<sourcecode>
    byte              SSH_AGENT_SUCCESS
		</sourcecode>
		<t>
		or a request-specific success message that may contain
		additional fields.
		On failure, the agent MUST reply with the single-byte response:
		</t>
		<sourcecode>
    byte              SSH_AGENT_FAILURE
		</sourcecode>
		<t>
		or a request-specific failure message that may contain
		additional fields.
		SSH_AGENT_FAILURE messages MUST also be sent in reply to
		requests with unknown or unsupported types.
		</t>
	</section>
	<section><name>Adding keys to the agent</name>
		<t>
		Keys may be added to the agent using the
		SSH_AGENTC_ADD_IDENTITY or
		SSH_AGENTC_ADD_ID_CONSTRAINED messages.
		The latter variant allows adding keys with
		optional constraints on their usage.
		</t>
		<t>
		The generic format for the key
		SSH_AGENTC_ADD_IDENTITY message is:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_ADD_IDENTITY
    string           key type
    byte[]           key data
    string           comment
		</sourcecode>
		<t>
		Here "key type" is the specified key type name, for example
		"ssh-rsa" for a RSA key as defined by
		<xref target="RFC4253" />.
		"key data" consists of the public and private components
		of the key and vary by key type, as specified in sub-sections
		<xref target="add-dsa" format="counter" /> through
		<xref target="add-rsa" format="counter" />
		for commonly used key types.
		"comment" is
		a human-readable key name or comment
		as a UTF-8 string that may serve to identify the
		key in user-visible messages. This string may be of zero length.
		</t>
		<t>
		The SSH_AGENTC_ADD_ID_CONSTRAINED is similar, but adds an
		extra field:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_ADD_ID_CONSTRAINED
    string           key type
    byte[]           key data
    string           comment
    constraint[]     constraints
		</sourcecode>
		<t>
		Constraints are used to place limits on the validity
		or use of keys.
		<xref target="constraints" /> details constraint types
		and their format.
		Clients SHOULD prefer the SSH_AGENTC_ADD_IDENTITY message
		over sending a SSH_AGENTC_ADD_ID_CONSTRAINED with an empty
		constraints field, though both are valid and equivalent.
		</t>
		<t>
		An agent MUST reply with SSH_AGENT_SUCCESS
		if the key was successfully loaded
		as a result of one of these messages, or
		SSH_AGENT_FAILURE otherwise.
		</t>
		<t>
		An agent MAY support only a subset of the key types defined
		here and MAY support additional key types as described below.
		If an agent does not recognise the type name in a request to
		add a key, then it MUST respond with a SSH_AGENT_FAILURE reply.
		</t>
		<section anchor="add-dsa"><name>DSA keys</name>
			<t>
			DSA keys have key type "ssh-dss" and are
			defined in <xref target="RFC4253" />. They
			may be added to the agent using the following
			message. The "constraints" field is only
			present for the SSH_AGENTC_ADD_ID_CONSTRAINED
			message.
			</t>
			<sourcecode>
    byte             SSH_AGENTC_ADD_IDENTITY or
                     SSH_AGENTC_ADD_ID_CONSTRAINED
    string           "ssh-dss"
    mpint            p
    mpint            q
    mpint            g
    mpint            y
    mpint            x
    string           comment
    constraint[]     constraints
			</sourcecode>
			<t>
			The "p", "q", "g" values are the DSA domain
			parameters. "y" and "x" are the public and
			private keys respectively. These values are
			as defined by Section 4.1 of
			<xref target="FIPS.186-4"/>.
			</t>
		</section>
		<section anchor="add-ecdsa"><name>ECDSA keys</name>
			<t>
			ECDSA keys have key types starting with
			"ecdsa-sha2-" and are defined in
			<xref target="RFC5656" />. They
			may be added to the agent using the
			following message.
			The "constraints" field is only present for
			the SSH_AGENTC_ADD_ID_CONSTRAINED message.
			</t>
			<sourcecode>
    byte             SSH_AGENTC_ADD_IDENTITY or
                     SSH_AGENTC_ADD_ID_CONSTRAINED
    string           key type
    string           ecdsa_curve_name
    string           Q
    mpint            d
    string           comment
    constraint[]     constraints
			</sourcecode>
			<t>
			The values "Q" and "d" are the ECDSA public and
			private values respectively. Both are defined
			by Section 6.2 of <xref target="FIPS.186-5"/>.
			</t>
		</section>
		<section anchor="add-eddsa"><name>EDDSA keys</name>
			<t>
			<xref target="RFC8709" /> defines Ed25519 and
			Ed448 with key type names "ssh-ed25519" and
			"ssh-ed448" respectively.
			These may be added to the agent using the
			following message. The "constraints"
			field is only present for
			the SSH_AGENTC_ADD_ID_CONSTRAINED message.
			</t>
			<sourcecode>
    byte             SSH_AGENTC_ADD_IDENTITY or
                     SSH_AGENTC_ADD_ID_CONSTRAINED
    string           "ssh-ed25519" or "ssh-ed448"
    string           ENC(A)
    string           k || ENC(A)
    string           comment
    constraint[]     constraints
			</sourcecode>
			<t>
			The first value is the EDDSA public key
			ENC(A).
			The second value is a concatenation of
			the private key k
			and the public
			ENC(A) key (this redundant repetition of the public key
			is to maintain compatibility with widely deployed
			implementations).
			The contents and interpretation of the
			ENC(A) and k values are
			defined by <xref target="RFC8032" section="3.2"/>.
			</t>
		</section>
		<section anchor="add-rsa"><name>RSA keys</name>
			<t>
			RSA keys have key type "ssh-rsa" and are
			defined in <xref target="RFC4253" />. They
			may be added to the agent using the following
			message. The "constraints" field is only
			present for the
			SSH_AGENTC_ADD_ID_CONSTRAINED message.
			</t>
			<sourcecode>
    byte             SSH_AGENTC_ADD_IDENTITY or
                     SSH_AGENTC_ADD_ID_CONSTRAINED
    string           "ssh-rsa"
    mpint            n
    mpint            e
    mpint            d
    mpint            iqmp
    mpint            p
    mpint            q
    string           comment
    constraint[]     constraints
			</sourcecode>
			<t>
			"n" is the public composite modulus.
			"e" is the public exponent.
			"d" is the private exponent.
			"p" and "q" are its constituent private
			prime factors.
			"iqmp" is the inverse of "q" modulo
			"p". All these values except "iqmp"
			(which can be calculated from the others)
			are defined by Section 5.1 of
			<xref target="FIPS.186-5" />.
			</t>
		</section>
		<section anchor="add-other"><name>Other keys</name>
			<t>
			Agents and their clients MAY support additional key
			types not documented here. Vendor-specific key types
			MUST use the domain-qualified naming convention
			defined in <xref target="RFC4251" section="6" />
			until code-points are allocated by IANA.
			</t>
		</section>
		<section><name>Adding keys from a token</name>
			<t>
			Keys hosted on smart-cards or other hardware
			tokens may be added using the
			SSH_AGENTC_ADD_SMARTCARD_KEY and
			SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED
			requests. Note that "constraints" field is only
			included for the
			SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED
			variant of this message.
			</t>
			<sourcecode>
    byte             SSH_AGENTC_ADD_SMARTCARD_KEY or
                     SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED
    string           token id
    string           PIN
    constraint[]     constraints
			</sourcecode>
			<t>
			Here "token id" is an opaque identifier for the
			hardware token and "PIN" is an optional
			password or PIN to unlock the key.
			The interpretation of "token id" is not defined
			by the protocol but is left solely up to
			the agent.
			</t>
			<t>
			Typically only the public components of
			any keys supported on a hardware token
			will be loaded into an agent so, strictly
			speaking, this message really arranges
			future private key operations to be
			delegated to the hardware token in question.
			</t>
			<t>
			An agent MUST reply with SSH_AGENT_SUCCESS
			if one or more keys were successfully loaded
			as a result of one of these messages, or
			SSH_AGENT_FAILURE if no keys were found.
			The agent MUST also return SSH_AGENT_FAILURE
			if the "token id" was not recognised or if
			the agent doesn't support token-hosted keys
			at all.
			</t>
		</section>
		<section title="Key Constraints" anchor="constraints">
			<t>
			A number of constraints may be used in the
			constrained variants of the key add messages.
			Each constraint is represented by a type byte
			followed by zero or more value bytes.
			</t>
			<t>
			Zero or more constraints may be specified when
			adding a key with one of the *_CONSTRAINED
			requests. Multiple constraints are appended
			consecutively to the end of the request:
			</t>
			<sourcecode>
    byte             constraint1_type
    byte[]           constraint1_data
    byte             constraint2_type
    byte[]           constraint2_data
    ....
    byte             constraintN_type
    byte[]           constraintN_data
			</sourcecode>
			<t>
			To fully parse a constraint, it is necessary to
			know its structure beforehand and it is not
			possible to safely recover when an unrecognised
			constraint is encountered.
			Given this, if an agent does not recognise or support a
			requested constraint it MUST abort parsing, refuse the
			request and return an SSH_AGENT_FAILURE message to the
			client.
			</t>
			<t>
			The following constraints are defined.
			</t>
			<section><name>Key lifetime constraint</name>
				<t>
				This constraint requests that the
				agent limit the key's lifetime by
				deleting it after the specified
				duration (in seconds) has elapsed
				from the time the key was added to
				the agent.
				</t>
				<sourcecode>
    byte             SSH_AGENT_CONSTRAIN_LIFETIME
    uint32           seconds
				</sourcecode>
			</section>
			<section><name>Key confirmation constraint</name>
				<t>
				This constraint requests that the
				agent require explicit user
				confirmation for each private key
				operation using the key. For example,
				the agent could present a confirmation
				dialog before completing a signature
				operation.
				</t>
				<sourcecode>
    byte             SSH_AGENT_CONSTRAIN_CONFIRM
				</sourcecode>
			</section>
			<section><name>Constraint extensions</name>
				<t>
				Agents may implement experimental
				or private-use constraints through
				a extension constraint that supports
				named constraints.
				</t>
				<sourcecode>
    byte             SSH_AGENT_CONSTRAIN_EXTENSION
    string           extension name
    byte[]           extension-specific details
				</sourcecode>
				<t>
				The extension name MUST consist of
				a UTF-8 string suffixed by the
				implementation domain following
				the naming scheme defined in
				<xref target="RFC4251" section="6" />,
				e.g.  "foo@example.com".
				</t>
				<t>
				Note, given the above requirement to reject
				keys with unsupported constraints, a constraint
				extension is only usable when both client
				and agent support it. Otherwise, the agent
				will be required to reject the key. This is
				desirable, as the constraint extension may
				specify limits on the key that, if ignored,
				may result in the key being available in
				situations the user did not intend (i.e. the
				agent will fail in a safe way).
				</t>
			</section>
		</section>
	</section>
	<section anchor="pubkeyblob"><name>Public key encoding</name>
		<t>
		Keys previously loaded into an agent are referred to by their
		public key blob, which is the standard SSH wire encoding for
		public keys. SSH protocol key encodings are defined in
		<xref target="RFC4253" /> for "ssh-rsa" and "ssh-dss" keys,
		in <xref target="RFC5656" /> for "ecdsa-sha2-*" keys and in
		<xref target="RFC8709" /> for "ssh-ed25519" and "ssh-ed448"
		keys.
		</t>
	</section>
	<section><name>Removing keys from the agent</name>
		<t>
		A client may request that an agent remove
		all keys that it stores:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_REMOVE_ALL_IDENTITIES
		</sourcecode>
		<t>
		On receipt of such a message, an agent
		MUST delete all keys that it is holding
		and MUST reply with SSH_AGENT_SUCCESS.
		</t>
		<t>
		Specific keys may also be removed:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_REMOVE_IDENTITY
    string           key blob
		</sourcecode>
		<t>
		Where "key blob" is the standard public key encoding of the
		key to be removed (<xref target="pubkeyblob" />).
		</t>
		<t>
		An agent MUST reply with SSH_AGENT_SUCCESS if the key was
		deleted or SSH_AGENT_FAILURE if it was not found.
		</t>
		<t>
		Token-hosted keys may be removed from an agent using:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_REMOVE_SMARTCARD_KEY
    string           token id
    string           PIN
		</sourcecode>
		<t>
		Where "token id" is an opaque identifier for the hardware token
		and "PIN" is an optional password or PIN (not typically
		used), both encoded using UTF-8.
		Requesting deletion of token-hosted keys MUST
		cause the agent to remove all keys it loaded from the device
		matching "token id".
		Note: this operation affects the agent only, it SHOULD NOT
		caese the keys be deleted from the token itself.
		</t>
		<t>
		An agent MUST reply with SSH_AGENT_SUCCESS if the key was
		deleted or SSH_AGENT_FAILURE if it was not found.
		</t>
	</section>
	<section><name>Requesting a list of keys</name>
		<t>
		A client may request a list of keys from an agent using the
		following message:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_REQUEST_IDENTITIES
		</sourcecode>
		<t>
		The agent MUST reply with a message with the following
		preamble.
		</t>
		<sourcecode>
    byte             SSH_AGENT_IDENTITIES_ANSWER
    uint32           nkeys
		</sourcecode>
		<t>
		Where "nkeys" indicates the number of keys to follow.
		Following the preamble are zero or more keys, each encoded as:
		</t>
		<sourcecode>
    string           key blob
    string           comment
		</sourcecode>
		<t>
		Where "key blob" is the standard public key encoding of the
		key (<xref target="pubkeyblob" />) and "comment" is a
		human-readable comment encoded as a UTF-8 string.
		</t>
	</section>
	<section><name>Private key operations</name>
		<t>
		A client may request the agent perform a
		private key signature operation using the
		following message:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_SIGN_REQUEST
    string           key blob
    string           data
    uint32           flags
		</sourcecode>
		<t>
		Where "key blob" is the key requested to perform the
		signature (encoded as per <xref target="pubkeyblob" />),
		"data" is the data to be signed and "flags" is a bitfield
		containing the bitwise OR of zero or more signature flags
		(see below).
		</t>
		<t>
		If the agent does not support the requested flags, or is
		otherwise unable or unwilling to generate the signature (e.g.
		because it doesn't have the specified key, or the user
		refused confirmation of a constrained key), it MUST reply
		with an SSH_AGENT_FAILURE message.
		</t>
		<t>
		On success, the agent MUST reply with:
		</t>
		<sourcecode>
    byte             SSH_AGENT_SIGN_RESPONSE
    string           signature
		</sourcecode>
		<t>
		The signature format is specific to the algorithm of the key
		type in use.  SSH protocol signature formats are defined in
		<xref target="RFC4253" /> for "ssh-rsa" and "ssh-dss" keys,
		in <xref target="RFC5656" /> for "ecdsa-sha2-*" keys and in
		<xref target="RFC8709" /> for "ssh-ed25519" and "ssh-ed448"
		keys.
		</t>
		<section><name>Signature flags</name>
			<t>
			Two flags are currently defined for
			signature request messages:
			SSH_AGENT_RSA_SHA2_256 and SSH_AGENT_RSA_SHA2_512
			(defined in <xref target="sigflagnum" />).
			These two flags are only valid for
			"ssh-rsa" keys and request that the agent
			return a signature using
			the "rsa-sha2-256" or "rsa-sha2-512"
			signature methods respectively. These
			signature schemes are defined in
			<xref target="RFC8332" />.
		</t>
		</section>
	</section>
	<section anchor="lock"><name>Locking and unlocking an agent</name>
		<t>
		The agent protocol supports requesting that an agent
		temporarily lock itself with a pass-phrase. When locked, an
		agent MUST suspend processing of sensitive operations
		(private key signature operations at the very least) until it
		has been unlocked with the same pass-phrase.
		</t>
		<t>
		The following message requests agent locking
		</t>
		<sourcecode>
    byte             SSH_AGENTC_LOCK
    string           passphrase
		</sourcecode>
		<t>
		The agent MUST reply with SSH_AGENT_SUCCESS if locked
		successfully or SSH_AGENT_FAILURE otherwise (e.g. if the agent
		was already locked).
		</t>
		<t>
		The following message requests unlocking an agent:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_UNLOCK
    string           passphrase
		</sourcecode>
		<t>
		If the agent is already locked and the pass-phrase matches the
		one used to lock it then it MUST unlock and reply with
		SSH_AGENT_SUCCESS. If the agent is already unlocked or if
		the pass-phrase does not match it MUST reply with
		SSH_AGENT_FAILURE.
		</t>
	</section>
	<section><name>Extension mechanism</name>
		<t>
		The agent protocol includes an optional extension mechanism
		that allows vendor-specific and experimental messages to be
		sent via the agent protocol. Extension requests from the
		client consist of:
		</t>
		<sourcecode>
    byte             SSH_AGENTC_EXTENSION
    string           extension type
    byte[]           extension request-specific contents
		</sourcecode>
		<t>
		The extension type indicates the type of the extension message
		as a UTF-8 string.  Implementation-specific extensions MUST
		be suffixed by the implementation domain following the
		extension naming scheme defined in
		<xref target="RFC4251" section="6" />, e.g. "foo@example.com".
		</t>
		<t>
		An agent that does not support extensions of the supplied type
		MUST reply with an empty SSH_AGENT_FAILURE message. This reply
		is also sent by agents that do not support the extension
		mechanism at all.
		</t>
		<t>
		The contents of successful extension reply messages are
		specific to the extension type.
		Successful extension requests MUST return
		either SSH_AGENT_SUCCESS on success or an extension-specific
		response message:
		</t>
		<sourcecode>
    byte             SSH_AGENT_EXTENSION_RESPONSE
    string           extension type
    byte[]           extension response-specific contents
		</sourcecode>
		<t>
		Where the extension type is the same as that in the request.
		</t>
		<t>
		Extension failure SHOULD be signaled using a
		SSH_AGENT_EXTENSION_FAILURE message:
		</t>
		<sourcecode>
    byte             SSH_AGENT_EXTENSION_FAILURE
		</sourcecode>
		<t>
		Extensions SHOULD NOT use
		the standard SSH_AGENT_FAILURE message. This allows failed
		requests to be distinguished from the extension not being
		supported.
		</t>
		<section anchor="queryext"><name>Query extension</name>
			<t>
			A single, optional extension request "query" is
			defined to allow a client to query which, if any,
			extensions are supported by an agent.
			</t>
		<sourcecode>
    byte             SSH_AGENTC_EXTENSION
    string           "query"
		</sourcecode>
			<t>
			If an agent supports the query extension it
			SHOULD reply with a list of supported extension names.
			</t>
			<sourcecode>
    byte             SSH_AGENT_EXTENSION_RESPONSE
    string           "query"
    string[]         supported extension types
			</sourcecode>
		</section>
	</section>
</section>

<section anchor="connecting"><name>Connecting to an agent</name>
	<t>
	Agents are exposed to the local system using a connection-oriented
	endpoint. On Unix-like systems, it is typical to arrange for
	the agent to listen on a filesystem-based Unix domain socket.
	On Microsoft Windows, it is usual to use a Windows Named Pipe.
	Access to these endpoints should be controlled as discussed in
	<xref target="Security" />.
	</t>
	<t>
	In both cases, it is common to expose the name or address of the
	listening endpoint via an environment variable named "SSH_AUTH_SOCK".
	Clients of an agent will use this variable to locate and connect to
	the listening agent. Agents alternately MAY use an implicit mechanism
	for clients to locate their endpoint, such as a default per-user
	location.
	</t>
</section>

<section anchor="fwd"><name>Forwarding access to an agent</name>
	<t>
	The agent protocol may be forwarded over an SSH connection, using the
	<xref target="RFC4254" /> connection protocol, allowing agent
	forwarding to be requested for any session channel, using a model
	that is similar to the connection protocol's support for X11 Forwarding
	(<xref target="RFC4254" section="6.3"/>).
	This feature is OPTIONAL for SSH protocol and agent implementations.
	</t>
	<section anchor="fwdext" title="Advertising agent forwarding support">
		<t>
		Support for agent forwarding may be advertised by an SSH
		server using the <xref target="RFC8308" /> extension
		mechanism using the name "agent-forward" in the
		SSH_MSG_EXT_INFO message.
		</t>
		<sourcecode>
    string           "agent-forward"
    string           "0" (version)
		</sourcecode>
		<t>
		Note that this protocol substantially predates the existence
		of the <xref target="RFC8308" /> extension mechanism and
		several widely-deployed SSH implementations that support agent
		forwarding do not advertise their ability to do so. SSH Clients
		MAY opportunistically attempt to request agent forwarding in
		the absence of an <xref target="RFC8308" /> advertisement
		using the vendor-specific names mentioned below.
		Likewise, SSH servers MAY implement the vendor-specific names in
		addition to the one described here.
		</t>
	</section>
	<section anchor="fwdreq"><name>Requesting agent forwarding</name>
		<t>
		An SSH client may request agent forwarding for a
		previously-opened session
		(<xref target="RFC4254" section="6.1" />) using the
		following channel request. This request is sent after the
		channel has been opened, but before a shell, command or
		subsystem has been executed.
		</t>
		<sourcecode>
    byte             SSH_MSG_CHANNEL_REQUEST
    uint32           channel_id
    string           "agent-req" or "auth-agent-req@openssh.com"
    boolean          want_reply
		</sourcecode>
		<t>
		Where channel_id is the identifier for an established session
		channel (as returned from a previous SSH_MSG_CHANNEL_OPEN
		request, and the want_reply flag indicates whether the SSH
		server should respond with a confirmation of whether the request
		was successful (as specified in
		<xref target="RFC4254" section="5.4"/>)
		</t>
		<t>
		If an SSH server accepts this request, typically it will arrange
		to make a endpoint (e.g. a listening socket) available and
		advertise this fact to the subordinate session. Most
		implementations on Unix-like systems do this by providing a
		user-private listening Unix domain socket and recording its
		location in an environment variable SSH_AUTH_SOCK.
		</t>
		<t>
		As mentioned previously, many deployed implementations only
		support the pre-standardisation
		"auth-agent-req@openssh.com" request name. The "agent-req" name
		SHOULD only be used if support was explicitly advertised as
		per <xref target="fwdext" />.
		</t>
	</section>
	<section anchor="fwdtype"><name>Agent connection requests</name>
		<t>
		After an SSH client has requested that a session have agent
		forwarding enabled, the SSH server later may request a
		connection to the forwarded agent. The SSH server does this by
		requesting a dedicated channel to communicate with the
		SSH client's agent.
		</t>
		<sourcecode>
    byte             SSH_MSG_CHANNEL_OPEN
    string           "agent-connect" or "auth-agent@openssh.com"
    uint32           channel_id
    uint32           local_window
    uint32           local_maxpacket
		</sourcecode>
		<t>
		The channel_id, local_window and local_maxpacket fields
		should be interpreted as specified by
		<xref target="RFC4254" section="5.1"/>.
		</t>
		<t>
		As above, the "agent-connect" open type name SHOULD only be
		used if support was explicitly advertised as per
		<xref target="fwdext" />.
		</t>
		<t>
		An SSH client SHOULD be prepared to handle multiple concurrent
		forwarded connections to a client-side agent, otherwise requests
		to access the agent from the remote side that happen to overlap
		prior requests may fail. Overlapping requests may occur because
		the SSH connection protocol <xref target="RFC4254" /> allows
		multiple user sessions over a single <xref target="RFC4253" />
		transport, which may each request use of the agentcw
		independently and potentially concurrently.
		</t>
		<t>
		An SSH client MAY accept agent connection requests (subject to
		authorisation) without a prior agent forwarding request having
		been made to support the situation where agent forwarding
		without opening a session is desired.
		Similarly, an SSH client MAY continue to accept agent connection
		requests after the session for which agent forwarding was
		requested has closed.
		</t>
		<t>
		An SSH client MUST refuse unauthorised agent connection
		requests, when agent forwarding is neither requested nor
		desired by the SSH client but an SSH server sends an agent
		connection request anyway.
		</t>
		<t>
		Because the "agent-connect" request contains no identifier to
		distinguish which session channel originated the connection
		request, an SSH connection can effectively forward
		access to only a single SSH client-side agent using
		this protocol (although there may be multiple concurrent
		connections to that single agent).
		</t>
	</section>
</section>

<section><name>Protocol numbers</name>
	<section anchor="messagenum" title="Message type numbers">
		<t>
		The following numbers are used as message types for requests
		from the client to the agent.
		</t>
		<sourcecode>
    SSH_AGENTC_REQUEST_IDENTITIES                  11
    SSH_AGENTC_SIGN_REQUEST                        13
    SSH_AGENTC_ADD_IDENTITY                        17
    SSH_AGENTC_REMOVE_IDENTITY                     18
    SSH_AGENTC_REMOVE_ALL_IDENTITIES               19
    SSH_AGENTC_ADD_SMARTCARD_KEY                   20
    SSH_AGENTC_REMOVE_SMARTCARD_KEY                21
    SSH_AGENTC_LOCK                                22
    SSH_AGENTC_UNLOCK                              23
    SSH_AGENTC_ADD_ID_CONSTRAINED                  25
    SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED       26
    SSH_AGENTC_EXTENSION                           27
		</sourcecode>
		<t>
		The following numbers are used as message types for replies
		from the agent to the client.
		</t>
		<sourcecode>
    SSH_AGENT_FAILURE                               5
    SSH_AGENT_SUCCESS                               6
    SSH_AGENT_IDENTITIES_ANSWER                     12
    SSH_AGENT_SIGN_RESPONSE                         14
    SSH_AGENT_EXTENSION_FAILURE                     28
    SSH_AGENT_EXTENSION_RESPONSE                    29
		</sourcecode>
		<section anchor="reservednum"><name>Reserved message type numbers</name>
			<t>
			The following message type numbers are reserved for
			implementations that implement support for the legacy
			SSH protocol version 1: 1-4, 7-10, 15-16 and
			24 (inclusive).
			These message numbers MAY be used by an
			implementation supporting the legacy protocol but
			MUST NOT be reused otherwise.
			</t>
			<t>
			Message number 0 is also reserved and MUST NOT
			be used.
			</t>
			<t>
			The range of message numbers 240-255 are reserved for
			Private Use extensions to the agent protocol and
			MUST NOT be used by generic implementations.
			</t>
		</section>
	</section>
	<section anchor="constraintid" title="Constraint identifiers">
		<t>
		The following numbers are used to identify key constraints.
		These are only used in key constraints and are not sent as
		message numbers.
		</t>
		<sourcecode>
    SSH_AGENT_CONSTRAIN_LIFETIME                    1
    SSH_AGENT_CONSTRAIN_CONFIRM                     2
    SSH_AGENT_CONSTRAIN_EXTENSION                   255
		</sourcecode>
		<t>
		The constraint identifier 0 is reserved.
		</t>
	</section>
	<section anchor="sigflagnum" title="Signature flags">
		<t>
		The following numbers may be present in signature request
		(SSH_AGENTC_SIGN_REQUEST) messages. These flags form a bit
		field by taking the logical OR of zero or more flags.
		</t>
		<sourcecode>
    SSH_AGENT_RSA_SHA2_256                          0x00000002
    SSH_AGENT_RSA_SHA2_512                          0x00000004
		</sourcecode>
		<t>
		The flag value 1 is reserved for historical implementations.
		</t>
	</section>
</section>

<section anchor="IANA"><name>IANA Considerations</name>
	<t>
	This protocol requires four registries be established, one for
	message type numbers, one for constraints, one for signature request
	flags and one for extension request names. Additionally,
	new codepoints are requested in three existing registries.
	</t>
	<section><name>Guidance for Designated Experts</name>
	<t>
	When a Designated Expert (DE) is asked to review additions to the
	new registries described above (<xref target="agentnum" />,
	<xref target="constraintnum" />, <xref target="sigflag" /> and
	<xref target="reqname" />), they are requested to verify that
	suitable documentation as described in <xref target="RFC8126" />
	exists and is permanently and publicly available.
	The DE is also requested to check the clarity of purpose and use of
	the requested code points. The DE should also verify that specifications
	produced in the IETF that request code points in these registries have
	been made available to the SSHM working group and the ssh@ietf.org
	mailing list for review. Requests for code points made for
	specifications produced outside the IETF should not conflict with
	active IETF work or prior IETF specifications.
	</t>
	<t>
	The available number of code points in the SSH agent protocol
	numbers (<xref target="agentnum" />) and SSH agent signature
	flags (<xref target="sigflag" />) registries are limited,
	so the DE is requested to ensure the use of code points is very well
	justified. For the SSH agent protocol numbers, named extension
	requests (<xref target="reqname" />) provide an alternative for most
	uses with no practical limitation on the number of available code
	points.
	</t>
	</section>
	<section anchor="agentnum"><name>New registry: SSH agent protocol message type numbers</name>
		<t>
		This registry, titled "SSH agent protocol message type numbers"
		records the message type numbers for client requests and
		agent responses.
		It should be created in the Secure Shell (SSH) Protocol
		Parameters registry group <xref target="IANA-SSH" />.
		Its initial state should consist of the following
		numbers and reservations.
		Future message number allocations shall occur via
		Expert Review as per <xref target="RFC8126" />.
		</t>
<table>
<thead>
<tr><th>Number(s)</th><th>Identifier</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>1</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>2</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>3</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>4</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>5</td><td>SSH_AGENT_FAILURE</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>6</td><td>SSH_AGENT_SUCCESS</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>7</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>8</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>9</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>10</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>11</td><td>SSH_AGENTC_REQUEST_IDENTITIES</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>12</td><td>SSH_AGENT_IDENTITIES_ANSWER</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>13</td><td>SSH_AGENTC_SIGN_REQUEST</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>14</td><td>SSH_AGENT_SIGN_RESPONSE</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>15</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>16</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>17</td><td>SSH_AGENTC_ADD_IDENTITY</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>18</td><td>SSH_AGENTC_REMOVE_IDENTITY</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>19</td><td>SSH_AGENTC_REMOVE_ALL_IDENTITIES</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>20</td><td>SSH_AGENTC_ADD_SMARTCARD_KEY</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>21</td><td>SSH_AGENTC_REMOVE_SMARTCARD_KEY</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>22</td><td>SSH_AGENTC_LOCK</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>23</td><td>SSH_AGENTC_UNLOCK</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>24</td><td>reserved</td><td>thisrfc, <xref target="reservednum" /></td></tr>
<tr><td>25</td><td>SSH_AGENTC_ADD_ID_CONSTRAINED</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>26</td><td>SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>27</td><td>SSH_AGENTC_EXTENSION</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>28</td><td>SSH_AGENT_EXTENSION_FAILURE</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>29</td><td>SSH_AGENT_EXTENSION_RESPONSE</td><td>thisrfc, <xref target="messagenum" /></td></tr>
<tr><td>240-255</td><td>Private Use</td><td>thisrfc, <xref target="messagenum" /></td></tr>
</tbody>
</table>
	</section>
	<section anchor="constraintnum"><name>New registry: SSH agent key constraint numbers</name>
		<t>
		This registry, titled "SSH agent key constraint numbers"
		records the message numbers for key use constraints.
		It should be created in the Secure Shell (SSH) Protocol
		Parameters registry group <xref target="IANA-SSH" />.
		Its initial state should consist of the
		following numbers.
		Future key constraint number allocations shall occur via
		Expert Review as per <xref target="RFC8126" />.
		</t>
<table>
<thead>
<tr><th>Number</th><th>Identifier</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>SSH_AGENT_CONSTRAIN_LIFETIME</td><td>thisrfc, <xref target="constraintid" /></td></tr>
<tr><td>2</td><td>SSH_AGENT_CONSTRAIN_CONFIRM</td><td>thisrfc, <xref target="constraintid" /></td></tr>
<tr><td>255</td><td>SSH_AGENT_CONSTRAIN_EXTENSION</td><td>thisrfc, <xref target="constraintid" /></td></tr>
</tbody>
</table>
	</section>
	<section anchor="sigflag"><name>New registry: SSH agent signature flags</name>
		<t>
		This registry, titled "SSH agent signature flags"
		records the values for signature request
		(SSH_AGENTC_SIGN_REQUEST) flag values.
		It should be created in the Secure Shell (SSH) Protocol
		Parameters registry group <xref target="IANA-SSH" />.
		Its initial state should consist of the
		following numbers. Note that as the flags are
		combined by bitwise OR, all flag values must be
		powers of two and the maximum available
		flag value is 0x80000000.
		</t>
		<t>
		Future signature flag allocations shall occur via
		Expert Review as per <xref target="RFC8126" />.
		</t>
<table>
<thead>
<tr><th>Number</th><th>Identifier</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>0x01</td><td>reserved</td><td>thisrfc, <xref target="sigflagnum" /></td></tr>
<tr><td>0x02</td><td>SSH_AGENT_RSA_SHA2_256</td><td>thisrfc, <xref target="sigflagnum" /></td></tr>
<tr><td>0x04</td><td>SSH_AGENT_RSA_SHA2_512</td><td>thisrfc, <xref target="sigflagnum" /></td></tr>
</tbody>
</table>
	</section>
	<section anchor="reqname"><name>New registry: SSH agent extension request names</name>
		<t>
		This registry, titled "SSH agent extension request names"
		records the names used in the generic extension request
		message (SSH_AGENTC_EXTENSION).
		It should be created in the Secure Shell (SSH) Protocol
		Parameters registry group <xref target="IANA-SSH" />.
		Its initial state should consist of the
		following names.
		</t>
		<t>
		Future name allocations shall occur via
		Expert Review as per <xref target="RFC8126" />.
		</t>
<table>
<thead>
<tr><th>Extension Name</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>query</td><td>thisrfc, <xref target="queryext" /></td></tr>
</tbody>
</table>
	</section>
	<section title="Additions to SSH Extension Names">
		<t>
		IANA is requested to insert the following entries into the
		table Extension Names <xref target="IANA-SSH-EXT" /> in
		the Secure Shell (SSH) Protocol Parameters registry group
		<xref target="IANA-SSH" />.
		</t>
<table>
<thead>
<tr><th>Extension Name</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>agent-forward</td><td>thisrfc, <xref target="fwdext" /></td></tr>
</tbody>
</table>
	</section>
	<section title="Additions to SSH Connection Protocol Channel Request Names">
		<t>
		IANA is requested to insert the following entries into the
		table Connection Protocol Channel Request Names
		<xref target="IANA-SSH-CHANREQ" /> in the
		Secure Shell (SSH) Protocol Parameters registry group
		<xref target="IANA-SSH" />.
		</t>
<table>
<thead>
<tr><th>Request Type</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>agent-req</td><td>thisrfc, <xref target="fwdreq" /></td></tr>
</tbody>
</table>
	</section>
	<section title="Additions to SSH Connection Protocol Channel Types">
		<t>
		IANA is requested to insert the following entries into the
		table Connection Protocol Channel Types <xref target="IANA-SSH-CHANTYPE" /> under
		Secure Shell (SSH) Protocol Parameters
		<xref target="IANA-SSH" />.
		</t>
<table>
<thead>
<tr><th>Request Type</th><th>Reference</th></tr>
</thead>
<tbody>
<tr><td>agent-connect</td><td>thisrfc, <xref target="fwdtype" /></td></tr>
</tbody>
</table>
	</section>
</section>

<section anchor="Security"><name>Security Considerations</name>
	<t>
	The agent is a service that is tasked with retaining and providing
	controlled access to what are typically long-lived login
	authentication credentials. It is by nature a sensitive and trusted
	software component. Moreover, the agent protocol itself does not
	include any authentication or transport security; ability to
	communicate with an agent is usually sufficient to invoke it to
	perform private key operations.
	</t>
	<t>
	Since being able to access an agent is usually sufficient to perform
	private key operations, it is critically important that the agent
	only be exposed to its owner and their authorised delegates.
	On Unix-like systems this may be achieved via filesystem permissions
	on the agent socket and/or identity checks on the client connected
	to a socket (e.g. SO_PEERCRED on some Unix-like systems).
	On Windows, access to a named pipe may controlled by attaching a
	security descriptor at the time of its creation.
	</t>
	<t>
	The primary design intention of an agent is that an attacker with
	unprivileged access to their victim's agent should be prevented from
	gaining a copy of any keys that have been loaded into it. This may
	not preclude the attacker from stealing use of those keys (e.g.
	if they have been loaded without a confirmation constraint).
	</t>
	<t>
	Given this, the agent should, as far as possible, prevent its
	memory being read by other processes to prevent theft of loaded keys.
	This typically includes disabling debugging interfaces and
	preventing process memory dumps on abnormal termination.
	</t>
	<t>
	Another, more subtle, means by which keys may be stolen are via
	cryptographic side-channels. Private key operations may leak
	information about the contents of keys via differences in timing,
	power use or by side-effects in the memory subsystems (e.g. CPU
	caches) of the host running the agent. For the case of a local
	attacker and an agent holding unconstrained keys, the only limit
	on the number of private key operations the attacker may be able
	to observe is the rate at which the CPU can perform signatures.
	This grants the attacker an almost ideal oracle for side-channel
	attacks.  While a full treatment of side-channel attacks is beyond
	the scope of this specification, agents SHOULD use cryptographic
	implementations that are resistant to side-channel attacks and MAY
	take additional measures to hide the actual time spent processing
	private key operations. Failure to do so may expose keys to recovery
	through these side-channels.
	</t>
	<t>
	Forwarding access to a local agent over an SSH connection
	(<xref target="fwd" />) inherently creates a transitive trust
	relationship. SSH implementations SHOULD NOT forward use of an agent
	by default, as doing so could expose access to the user's keys to
	untrusted hosts they connect to. Agents SHOULD implement additional
	controls over key visibility and use for forwarded agent connections,
	otherwise the user has only an all-or-nothing choice over whether to
	forward an agent.
	</t>
	<t>
	Implementation of token/smartcard-hosted keys requires some care too.
	On some systems, tokens may invoked by providing a path to shared
	library that must be loaded to make use of keys hosted on the device
	(a path to a library for a particular PKCS#11 module, for example).
	Loading a shared library on most platforms implies automatic
	execution of code in that library in the address space of
	the process that loads it.
	To avoid loading of potentially-hostile code, agents that support
	loading token-hosted keys via library path SHOULD ensure that only
	trusted token provider libraries are loadable.
	Additionaly agents SHOULD ensure that loaded token library code
	cannot gain access to other keys loaded in the agent and MAY disallow
	remote clients from loading token keys entirely.
	Protection for existing keys from tokey library code may be achieved
	by loading the token library into a separate process to the agent
	and arranging for the agent to invoke token operations to this
	process via IPC.
	</t>
	<t>
	Finally, with respect to the agent locking functionality in
	<xref target="lock" />, an agent SHOULD take countermeasures
	against brute-force guessing attacks against the pass-phrase.
	This may take the form of enforced delays when an unlock attempt is
	made with an incorrect password (potentially increasing for subsequent
	failures), a lockout period where the agent refuses to accept further
	requests after some threshold of failed unlock attempts has been made
	and/or deletion of all keys held by the agent after a threshold of
	failed unlock attempts.
	</t>
</section>
<section removeInRFC="true" anchor="implstatus"><name>Implementation Status</name>
	<t>
	Note to editor: please also remove the orphaned reference to RFC7942.
	</t>
	<t>
	This section records the status of known implementations of the
	protocol defined by this specification at the time of posting of
	this Internet-Draft, and is based on a proposal described in
	<xref target="RFC7942" />. The description of implementations in
	this section is intended to assist the IETF in its decision processes
	in progressing drafts to RFCs. Please note that the listing of any
	individual implementation here does not imply endorsement by the
	IETF. Furthermore, no effort has been spent to verify the
	information presented here that was supplied by IETF contributors.
	This is not intended as, and must not be construed to be, a
	catalog of available implementations or their features. Readers
	are advised to note that other implementations may exist.
	</t>
	<t>
	According to <xref target="RFC7942" />, "this will allow reviewers
	and working groups to assign due consideration to documents that
	have the benefit of running code, which may serve as evidence of
	valuable experimentation and feedback that have made the implemented
	protocols more mature. It is up to the individual working groups
	to use this information as they see fit".
	</t>
	<t>
	The following projects maintain an implementation of this
	protocol:
	</t>
	<dl>
		<dt>OpenSSH</dt>
		<dd>
		<t>
		OpenSSH is the originating implementation of this protocol and
		has supported it since 2000.
		</t>
		<t>
		Website: https://www.openssh.com/
		</t>
		</dd>

		<dt>PuTTY</dt>
		<dd>
		<t>
		PuTTY is a popular SSH client implementation for multiple
		platforms that has included a compatible agent client since
		2001.
		</t>
		<t>
		Website: https://www.chiark.greenend.org.uk/~sgtatham/putty/
		</t>
		</dd>

		<dt>Dropbear</dt>
		<dd>
		<t>
		Dropbear is an SSH client and server implementation for Unix-
		like systems. It has supported the agent protocol since 2005.
		</t>
		<t>
		Website: https://matt.ucc.asn.au/dropbear/dropbear.html
		</t>
		</dd>

		<dt>Paramiko</dt>
		<dd>
		<t>
		Paramiko is an SSH client and server implementation in the
		Python programming language. It has supported an agent protocol
		implementation since 2005.
		</t>
		<t>
		Website: https://www.paramiko.org/
		</t>
		</dd>

		<dt>Golang x/crypto/ssh/agent</dt>
		<dd>
		<t>
		The Go programming language project has supported an
		implementation of this protocol in its external "x" repository
		since 2015.
		</t>
		<t>
		Website: https://pkg.go.dev/golang.org/x/crypto/ssh/agent
		</t>
		</dd>
	</dl>
	<t>
		This list is not exhaustive.
	</t>
</section>
</middle>

<back>
<references>
	<name>References</name>
	<references><name>Normative References</name>
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4251.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4253.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4254.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5656.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8308.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8332.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8709.xml" />
		<reference anchor="FIPS.186-4">
			<front>
				<title>Digital Signature Standard (DSS)</title>
				<author>
					<organization>
						National Institute of
						Standards and Technology
					</organization>
				</author>
				<date month="July" year="2013" />
			</front>
			<refcontent>FIPS PUB 186-4</refcontent>
			<seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
		</reference>
		<reference anchor="FIPS.186-5">
			<front>
				<title>Digital Signature Standard (DSS)</title>
				<author>
					<organization>
						National Institute of
						Standards and Technology
					</organization>
				</author>
				<date month="February" year="2023" />
			</front>
			<refcontent>FIPS PUB 186-5</refcontent>
			<seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-5"/>
		</reference>
	</references>

	<references><name>Informative References</name>
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.4252.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml" />
		<xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml" />
		<reference anchor="IANA-SSH-CHANREQ" target="https://www.iana.org/assignments/ssh-parameters/"><front>
			<title>Connection Protocol Channel Types</title>
			<author>
				<organization>IANA</organization>
			</author>
		</front></reference>       
		<reference anchor="IANA-SSH" target="https://www.iana.org/assignments/ssh-parameters/ssh-parameters.xhtml"><front>
			<title>Secure Shell (SSH) Protocol Parameters</title>
			<author>
				<organization>IANA</organization>
			</author>
		</front></reference>       
		<reference anchor="IANA-SSH-CHANTYPE" target="https://www.iana.org/assignments/ssh-parameters/"><front>
			<title>Extension Names</title>
			<author>
				<organization>IANA</organization>
			</author>
		</front></reference>       
		<reference anchor="IANA-SSH-EXT" target="https://www.iana.org/assignments/ssh-parameters/"><front>
			<title>Connection Protocol Channel Request Names</title>
			<author>
				<organization>IANA</organization>
			</author>
		</front></reference>       
		<!-- XXX bibtex gives me xml2rfc errors -->
		<!-- <xi:include href="https://datatracker.ietf.org/doc/bibxml3/draft-ietf-secsh-agent-02.xml" /> -->
		<reference anchor="draft-ietf-secsh-agent-02" target="https://datatracker.ietf.org/doc/html/draft-ietf-secsh-agent-02"><front>
			<title>Secure Shell Authentication Agent Protocol</title>
			<author surname="Ylonen" fullname="Tatu Ylonen" />
			<author surname="Rinne" fullname="Timo J. Rinne" />
			<author surname="Lehtinen" fullname="Sami Lehtinen" />
			<date year="2004" month="January"/>
			<abstract>
				<t>
				This document describes the Secure Shell
				authentication agent protocol (i.e., the
				protocol used between a client requesting
				authentication and the authentication agent).
				This protocol usually runs in a
				machine-spe-cific local channel or over a
				forwarded authentication channel. It is
				assumed that the channel is trusted, so no
				protection for the communications channel
				is provided by this protocol.
				</t>
			</abstract>
		</front></reference>
	</references>
</references>

<!--   
<section><name>Appendix 1</name>
	<t>
	This becomes an Appendix
	</t>
</section>
-->

<section anchor="Acknowledgments" numbered="false"><name>Acknowledgments</name>
	<t>
	This protocol was designed and first implemented by
	Markus Friedl, based on a similar protocol for an agent
	to support the legacy SSH version 1 by Tatu Ylonen.
	</t>
	<t>
	Thanks to Simon Tatham, Niels Mller, James Spencer, Simon Josefsson,
	Matt Johnston, Jakub Jelen, Rich Salz, Caspar Schutijser,
	Florian Obser, Martin Thomson, Deb Cooley and Tero Kivinen who reviewed
	and helped improve this document.
	</t>
</section>


<!--
<section anchor="Contributors" numbered="false"><name>Contributors</name>
	<t>Thanks to all of the contributors.</t>
	<contact fullname="Jane Doe" initials="J" surname="Doe">
	<organization>Acme</organization>
	<address>
	<email>jdoe@example.com</email>
	</address>
	</contact>
</section>
-->

</back>
</rfc>
